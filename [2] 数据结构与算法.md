# 数据结构与算法常考问题

## 数组和链表的区别

数组和链表都是线性结构，每个元素都有唯一的前驱和后继，他们的区别在于：

数组是将元素在内存中连续存放，由于每个元素占用的空间相同，可以通过下标迅速访问数组中的任何元素。数组的插入和删除效率很低，插入时，当前位置后面的所有元素都要向后移动，删除时，当前位置后面的所有元素都要向前移动。由于数组的随机读取效率很高，所以它适用于快速访问数据，很少或者不需要增加删除元素的应用。但是使用数组需要预留空间，可能会造成空间的浪费，并且它不利于扩展，如果定义的空间不够，需要重新定义数组。

- 数组优点：随机访问性强；查找速度快。O(1)
- 数组缺点：插入删除效率低；预留空间造成空间浪费；内存空间要求高，必须有足够的连续的内存空间；数组大小固定，不能动态扩展。

链表在内存中不是顺序存储的，而是通过元素中的指针链接在一起的，如果要访问链表中一个元素，需要从链表的第一个元素开始，一直遍历找到所需的元素。但是增加删除比较方便，只需要修改元素中的指针指向。适用于需要频繁插入和删除的应用，不需要指定大小，扩展方便。

- 链表优点：插入删除速度快；内存利用率高，不会浪费空间；大小不固定，扩展灵活。
- 链表缺点：不能随机查找，只能从第一个开始遍历，查找效率低。O(n)

## 如何找到一个有环链表的入口结点

1. 判断是否有环：定义两个指针，快指针一次走两个节点，慢指针一次走一个节点，如果两个指针相遇，则证明该链表有环。
2. 找环的入口节点：定义两个指针，一个从刚才相遇位置出发，另一个从链表头节点出发，两个指针一次都走一个节点，相遇位置即为环的入口节点。

![image-20230323154338530](C:\Users\zj\AppData\Roaming\Typora\typora-user-images\image-20230323154338530.png)

## 如何将两个有序链表合并成一个有序链表

两个指针分别从两个链表的头节点开始遍历，比较按照数据大小顺序插入到第一个链表中，判断如果其中一个链表已经遍历结束，那么将另一个链表剩下的部分全部添加到新的有序链表的尾部。

## 如何用两个队列实现栈

1. 申请两个队列。
2. 入栈：两个队列都为空时，随便选一个入队；如果有队列不为空，那么选不为空的队列入队。
3. 出栈：将不为空的队列中除最后一个元素之外的其他所有元素出队，放入另一个队列，最后一个元素出队即完成一次出栈。

## 如何用两个栈实现队列

1. 申请两个栈s1和s2，s1用来入队，s2用来出队。
2. 入队：s1入栈。
3. 出队：判断s2是否为空，如果不为空，s2出栈即完成一次出队；如果为空，将s1中的元素全部出栈到s2中，s2出栈即完成一次出队。

## 哈希表如何创建，哈希冲突的解决办法

1. 首先确定散列函数，一般采用f = key % n，新来数据根据散列函数计算出下标，将该数据放入对应下标即可。当再来数据计算的下标与之前发生冲突时，要解决冲突。

2. 确定解决冲突的办法有两种，分别是开放地址法和拉链法：

   开放地址法：将产生冲突的数据放入当前哈希表中空闲位置。可以采用线性探测的方式，当前下标发生冲突，从当前下标开始向后遍历，哪里有空放哪里；也可以采用，采用当前下标+-1，+-4，+-9的方法探测空闲位置，这样比一个一个遍历效率能高一些。

   拉链法：哈希表中存放指针，每个指针至指向一个单向链表，新来数据根据散列函数计算出下标，采用头添加的方式添加下标所对应的链表中。

## 哈希表的增删查时间消耗是多少

O(1)

## 哈希冲突的优化，两种方法的对比

1. 拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短。
2. 由于拉链法中各链表上的节点空间是动态申请的，故它更适合于造表前无法确定表长的情况。
3. 开放定址法为减少冲突，要求装填因子α较小（装填因子 = 个数/表长），故当节点规模较大时会浪费很多空间。而拉链法中可取α≥1，且节点较多时，拉链法中增加的指针域可忽略不计，因此节省空间。
4. 在用拉链法构造的散列表中，删除节点的操作易于实现。只要简单地删去链表上相应的节点即可。而对开放地址法构造的散列表，删除节点不能简单地将被删节点的空间置为空，否则将截断在它之后填入散列表的同义词节点的查找路径。这是因为各种开放地址法中，空地址单元（即开放地址）都是查找失败的条件。因此在用开放地址法处理冲突的散列表上执行删除操作，只能在被删节点上做删除标记，而不能真正删除节点。

## 给定前序和中序如何推出二叉树的后序遍历

前序的遍历顺序为根左右，根据前序序列能够确定根节点的位置，中序的遍历顺序为左右根，根据中序序列能够确定根的左子树和根的右子树。

## 如何判断一个给定的序列是排序二叉树的后序序列

## 二叉树的层序遍历如何进行

1. 申请队列来保存未处理节点。

2. 将根节点入队，循环判断队列是否为空。

   如果队列不为空，处理队列第一个元素，打印，出队，将该节点的左子树和右子树入队。

   如果队列为空，结束循环。

## 如何判断一个数是否是2的幂，时间复杂度是多少，有没有其他解决办法

## 二叉树的非递归中序遍历如何实现

## 二叉树的非递归前序遍历如何实现

## 如何通过前序遍历反向构造一棵二叉树

## 图的邻接矩阵和邻接链表的区别

## 图的最小生成树如何生成

Kruskal：

Prim：

## 一个有n个节点的无向图中最少有几条边才一定是连通图

n

## 一个有n个节点的有向完全图中最少有几条边

An2 = n(n-1)

## 一个有n个节点的无向完全图中最少有几条边

Cn2 = n(n-1)/2

## 给你一组数据，如何创建一棵完全二叉树

## 

## 

## 哈夫曼树叶子结点有2n个，总结点有多少个

##  

## 如何将一棵BST变成一个有序的双向链表

中序遍历，

O(1)

## 一棵完全二叉树，叶子结点有124个，问这棵树最多有多少个结点

## 什么是B树

![image-20230404221109742](C:\Users\zj\AppData\Roaming\Typora\typora-user-images\image-20230404221109742.png)

B 树又叫平衡多路查找树。一棵m阶的B 树 (m叉树)的特性如下：

1. 根节点至少有两个孩子 。
2. 每个非根节点至少有m/2（上取整）个孩子，至多有m个孩子。
3. 每个叶子节点 至少有 m/2-1（上取整）个关键字，至多有 m-1 个关键字。并以升序排列。（注：叶子节点是没有孩子）
4. key[i] 和 key[i+1] 之间的孩子节点的值介于 key[i] 和 key[i+1] 之间。
5. 所有的叶子节点都在同一层。

## 什么是B+树

![image-20230404221405152](C:\Users\zj\AppData\Roaming\Typora\typora-user-images\image-20230404221405152.png)

B+树节点是一组按照key有序的元素，B+树包含两种类型的节点，一种是索引节点，一种是叶子节点

索引节点也叫内部节点，索引节点只包含key，不包含data, 节点的 key是升序排列的，对于指定的索引节点key来说，它左子树上所有的key都小于它的key，它右子树上所有的key都大于等于它的key。

叶节点上存储的是主键和数据(key和data), 所有的叶节点都在同一高度上，节点按key 从小到大并且通过指针使得彼此链接，这样，所有的叶节点组成了一个双向有序链表，叶节点这样做的好处是在不访问索引的情况下能顺序检索数据，也能很好的支持范围查询的快处理。

B+树的特点：

1. 阶数为m的B+树，每个索引节点最多有m个子节点，每个索引节点页面最多存储m-1个索引key
2. 所有索引节点的子节点数在Math.ceil(m/2) 和m之间
3. B+树之所以称为平衡树，是因为从根节点到叶节点的每条路径都具有相同的长度。平衡树意味着所有对单个值的搜索都需要从磁盘读取相同数量的页面。

填充因子

B+树使用填充因子来控制页面的分裂和合并，设置数据占用页面空间的百分比，目的是为后面的数据预留一部分页空间，当有新数据时，可以放到预留的页空间中，避免分页的发生。默认的填充因子是50%，对于一棵m阶的B+树，填充因子是m/2

## B树和B+树的区别

B树和B+树都是一种常用的多叉搜索树，常用于数据库索引、文件系统等领域。它们的主要区别在于：

1. 存储方式：

   B树中每个节点都包含了key和value，而且根节点到叶子节点的路径上所有节点都是有用的，因此在B树中，每个节点都可以作为关键字查找所对应的记录。

   B+树中只有叶子节点包含了key和value，而且叶子节点之间形成了一个有序的链表。根节点到叶子节点的路径上所有非叶子节点只是用来索引，因此在B+树中，只有叶子节点可以作为关键字查找所对应的记录。

2. 结点结构

   B树中一个节点可以拥有大于等于两个分支，而且分支个数可以动态增加和减少，因此B树的节点可以非常大。

   B+树中一个节点通常比B树小，因为非叶子节点只是用来存储索引而不是真正的数据，而且叶子节点只存储key和value，不存储指针，因此B+树的节点数通常比B树多，但每个节点的大小却相对较小。

3. 查找性能：

   B树和B+树的查找性能相差不大，这是由于页的大小和树的高度等因素综合影响的。

4. 遍历性能：

   B树的遍历性能优于B+树，因为B树的每个节点都包含了key和value，因此可以直接在节点中访问数据。而在B+树中，每个叶子节点只存储了key和value，需要通过指针进行遍历，因此性能稍低。

5. 范围查询

   由于B+树非叶子节点只用作索引，而所有查询都必须查找到叶子节点，所有数据都在叶子节点上，因此B+树非常适合范围查找和扫描操作；而B树在进行范围查询时需要进行多次磁盘I/O操作，因此B+树在范围查询上具有优势。

## 如何进行单向链表的倒置（倒序打印）

1. 用栈，遍历链表，将数据入栈
2. 头插，
3. 三个指针，原地倒置

## 如何进行一个单向链表的折叠

1. 先找到链表中间位置，遍历得出链表长度，再走到它长度的1/2处，标记后半部分的链表头
2. 将后半部分链表倒置
3. 前半部分和后半部分交替添加

## 红黑树增删查的时间复杂度

logn

## 红黑树的添加

## 红黑树添加时最多几次旋转结束，删除时最多几次旋转结束

2，3

## 有n级台阶，青蛙一次只能蹦一级或两级，共有几种跳法



## 如何判断一个单向链表是否是回文链表

1. 遍历链表，将每个结点值入栈
2. 链表倒置
3. 

## 排序二叉树的删除

## 连通图的概念

## 如何求一个字符串的全排列

## 什么是DAG，AOV

有向无环图，

AOV网络用来求拓扑排序

## 图的BFS

## 图的DFS

## 有一个数组，这个数组里有两个元素只出现一次，其他的都出现两次，问怎么快速找到这两个只出现一次的元素

1. 哈希，统计个数
2. 

## 二叉树性质的第五条

将一棵完全二叉树，从上到下从左到右从1开始编号，编号为i的节点如果满足 2i <= n 就是有左孩子，2i+1 <= n 就是有右孩子，否则就是没有（父亲节点的编号范围为1~n/2）

将一棵完全二叉树，从上到下从左到右从0开始编号，编号为i的节点如果满足 2i+1 < n 就是有左孩子，2i+2 < n 就是有右孩子，否则就是没有（父亲节点的编号范围为0~n/2-1）

## 给你一个数组，前半部分单调递减，后半部分单调递增，如何找到数组中的最小值

## 哈夫曼编码如何实现

## 一个有2n个叶子结点的哈夫曼树共有几个结点

## 如何查找链表的倒数第k个结点，有没有什么细节需要考虑，时间复杂度是多少

快慢指针，两个指针都指向链表头结点，快指针先走k个结点，

## 查找一个字符串在另一个字符串中首次出现的下标

kmp：

sunday：

## 如何实现字符串反转

1. 栈
2. 定义两个指针，一个从头往后走，一个从尾往前走，使用下标访问，交换位置。

## 如何不使用中间变量，实现两个变量的交换

三次异或

a = a^b

b = a^b

a = a^b

## 约瑟夫环

1. 队列模拟
2. 递归

## 如何不用加减乘除实现加法运算



## 给你一万个括号，判断是否匹配

1. 遍历，遇到左括号入栈，遇到有括号，出栈，遍历结束栈为空则是匹配的

## 如何判断一个给定的序列是不是BST的后序序列

## 红黑树的性质

1. 结点要么是红色，要么是黑色
2. 根节点一定是黑色
3. 认为空结点都是黑色
4. 不允许父子结点都为红色
5. 从任意节点向下出发，所能到达的各个终端节点的各条路径中黑色节点的个数必须是相同的

## 给你一堆字符串，统计其中某个字符串出现的次数

1. 哈希表
2. 字典树

## 从右侧向左侧看一棵二叉树，看到的是哪些结点

## 一个数组有n个元素，每个元素的大小在0~n-1范围内，问这组数里是否有元素重复出现

1. 哈希，统计每个元素出现的次数
2. 把数字当下标用，遍历数组

## 一个有k层的二叉树，总的结点个数最多有多少个，叶子结点最多有多少个

2^k-1，2^(k-1)

## 一个有n个节点的完全二叉树高度是多高

logn向下取整+1

## 一个有向的带正权值的图中，一个点到其他各点的最短距离

迪杰斯特拉

## 给定前序和中序，构造二叉树

## 给一个前序序列，给一个后序序列，能否构造出二叉树

不能，因为不能确定根的位置，也就不能将序列分为左子树和右子树，所以不能构造出二叉树

## 如何将n个有序链表合并成一个有序链表

两两合并，将两个链表合并成一个有序链表

## 复杂链表的复制

## 如何找到一个字符串内第一个只出现一次的字符

1. 使用unordered_map，遍历字符串，统计每个字符串出现的个数，存入map，遍历map，即可找到第一个只出现一次的字符
2. 

## 二叉树的前序遍历怎么实现

递归：根节点为空，直接return，根节点不为空，先打印当前节点，递归调用，将当前节点的左子树传入，递归调用，将当前节点的右子树传入

## 如何判断两个单向链表是否有交点

两个指针同时走

## 在一个有序数组里想要找到某个数字，如何查找

二分，两个指针，判断当前想要查找的数字和

## 拓扑排序怎么实现

1. 预处理每个结点，入度为0的点入队
2. 处理入度为0的点，更新其他结点的入度

## 什么样的问题能用分治法来解决

1. 一个问题能分成若干个子问题，每个子问题相互独立，且解决办法相同
2. 

## 什么样的问题能用递归来解决

## 给定字符串，将字符串的倒数k个字符移动到前面

将0~k-1反转，将k~len-1反转，再将整个字符串反转即可

## 计算时间复杂度的三个要求

## 复合判断两个单向链表是否有交点，时间消耗和空间消耗

1. 遍历，两个链表的长度

## 二叉树的右旋

三个孩子，三个父亲的关系

## BST是如何创建的

创建是通过添加来完成的，添加的过程实际上是比较大小的过程，具体添加过程如下：

检测当前是否为空树，如果为空，新节点为根，结束；如果不为空，新节点的值与根结点的值进行比较，比根大的话，去右子树，右子树为空，就插入，不为空继续比较，比根小的话去左子树，左子树为空就插入，不为空继续比较。

## 如何计算一个数字的n次幂

分治：

## 什么时候使用哈希表，什么时候使用红黑树

## 一个数组先递增后递减，如何找到目标值

## 在一棵BST里，如何搜索和为s的整数对

## 斐波那契的实现

递归：

循环：

## atoi函数是怎么实现的

## 一个有n个节点的二叉树的高度如何计算

logn向下取整+1

## 如何计算一个数字的二进制里1的个数

## 什么叫强连通分量

## 如何判断字符串是否是回文的

## 用数组实现循环队列，想要进行push和pop，它的头尾要怎么移动

数组大小为n，push时，(tail+1)%n，pop时，(tail-1)%n

## 有n个节点的二叉树搜索，时间消耗

## 在一棵二叉树中，如何计算某个结点的高度

## vector和list的区别

## 二叉树后序遍历

后序遍历的顺序是左右根，而处理左子树和右子树的方式与处理个人根的方式相同，于是采取递归的方式来实现

递归：先处理当前节点的左子树，再处理当前结点的右子树，左右子树都处理完成后，再处理根节点，如果根节点的左子树为空且右子树为空则return。

## 如何查找二叉树中和为某个值的路径

## 给你一组数据，奇数放一起，偶数放一起

